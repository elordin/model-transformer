modeltype IOAutomaton uses IOAutomaton('se.studieren.mdd.transformer.IOAutomaton');
modeltype IOAutomatonPackage uses IOAutomatonPackage('se.studieren.mdd.transformer.IOAutomatonPackage');
modeltype StateMachine uses StateMachine('se.studieren.mdd.transformer.StateMachine');
modeltype StateMachinePackage uses StateMachinePackage('se.studieren.mdd.transformer.StateMachinePackage');
// modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');

transformation Step05(in ioAutomatonPackage : IOAutomatonPackage, out stateMachinePackage : StateMachinePackage);

main() {
	ioAutomatonPackage.objectsOfType(IOAutomatonPackage::IOAutomatonPackage).map toStateMachinePackage();
}

mapping IOAutomatonPackage::IOAutomatonPackage::toStateMachinePackage() : StateMachinePackage::StateMachinePackage {
	var st := OrderedSet{};
	statemachine += self.ioautomaton.toStateMachine(result);
	
	statemachine += st;
	
	
}

helper IOAutomaton::IOAutomaton::toStateMachine(inout stp: StateMachinePackage::StateMachinePackage ) : StateMachine::StateMachine {
	var stateMachine = self.name.map stringToStateMachine(); 
	
	var functionNames := self.getFunctionNames();
	var mainRegion = self.map toRegion(stateMachine.region);
	stateMachine.region += mainRegion;
	
	stp.statemachine += functionNames.generateSubmachines(self, mainRegion)->asSequence();

	return stateMachine
	
	
}
mapping IOAutomaton::IOAutomaton::toRegion(in regions : Set(StateMachine::Region)) : StateMachine::Region {
	name := "Main Region";

	subvertex += self.vertex.map toState();
	
	
	//subvertex += activityStates->collect(name);
	// TODO Create Activity Diagrams 
	// TODO Create Submachines
	// TODO Create Transitions
}

helper String::generateSubmachines(in iOAutomaton : IOAutomaton::IOAutomaton, inout mainReg : StateMachine::Region ) : StateMachine::StateMachine{
	
	var subMach := self.map stringToStateMachine();
	var reg := self.map stringToRegion();
	subMach.region := reg;
	/// Initial State
	var initState = self.map constructInitState();	
	reg.subvertex += initState;
	
	///Transitions used in this submachine
	var relatedTransitions := iOAutomaton.transition->select(inmessage != null)->select(inmessage.operation.name=self)->asSequence();
	log("test", self);
	var first := foo(relatedTransitions,1,reg);
	var trans := map constructInternalTransition(initState,first);
	reg.transition += trans;
	
	//State for main
	var submachineState := self.map constructState();
	submachineState.submachine := subMach;
	mainReg.subvertex += submachineState;
	
	
	return subMach;
}

mapping String::stringToStateMachine() : StateMachine::StateMachine{
	name := self;
}

mapping String::stringToRegion() : StateMachine::Region{
	name := self;
}

helper foo(in corrTransitions : Sequence(IOAutomaton::Transition), in count : Integer, inout reg : StateMachine::Region) : StateMachine::State{
	var oMessages := corrTransitions->first().outmessage->asSequence();
	var statename := "do / ";
	var i := count;
	
	while(oMessages->at(i).returnvalue.oclIsKindOf(VoidValue) and i <= oMessages->size()){
		statename := statename + oMessages->at(i).getOutMessageSignature();
		i := i + 1;
	};
	
	if( oMessages->at(i).returnvalue.oclIsKindOf(Value) and i <= oMessages->size() ){
		statename := statename + oMessages->at(i).getOutMessageSignature();
	};
	
	var state := statename.map toActionState();	
	if(i != count){	//If no return value add state
		reg.subvertex += state;		
	};
	
	if( oMessages->at(i).returnvalue.oclIsKindOf(Value) and i <= oMessages->size() ){
		reg.subvertex += state;
		var results = corrTransitions.getResultsAt(i)->asSet();
		results->forEach(res){
			var resultingTransactions :=  corrTransitions->select(outmessage->at(i).returnvalue.oclAsType(Value).name = res);
			log ("123",resultingTransactions.outmessage->at(i).returnvalue.oclAsType(Value).name);
			var next := foo(resultingTransactions,i+1,reg);
			var condition := "check = " + res;
			log("cond", condition);
			var trans := condition.map constructInternalGuardedTransition();
			trans.source := state;
			trans.target := next;
			reg.transition += trans;
		};
	};
	
	//should never occur, as this is loop condition, but to do a complete case for Kind
	if(oMessages->at(i).returnvalue.oclIsKindOf(VoidValue) and i <= oMessages->size()){
		log("ERROR","should never be called");
	};
	
	if(i = count or not (oMessages->at(i).returnvalue.oclIsKindOf(Value) and i <= oMessages->size()) ){
		reg.subvertex += state;
	};
	
	//TODO: Missing exitPointsStates
	
	return state;
}


mapping  String::constructInternalGuardedTransition() : StateMachine::Transition{
	guard := self.map constructConstraint();
	kind := TransitionKind::internal;
}

mapping  constructInternalTransition(in sou : StateMachine::Vertex, in tar : StateMachine::Vertex) : StateMachine::Transition{
	kind := TransitionKind::internal;
	source := sou;
	target := tar;
}

mapping  String::constructConstraint() : StateMachine::Constraint{
	constraint := self;
}


helper IOAutomaton::Transition::getResultsAt(in i:Integer) : String {
	return self.outmessage->at(i).returnvalue.oclAsType(Value).name;
}

helper IOAutomaton::OutMessage::getOutMessageSignature() : String {
//TODO check only if return value
	var ret := "";
	if(self.returnvalue.oclIsKindOf(Value)){
		ret := " check := ";
	};
	return ret+getRecieverName(self.actorobject)+"."+self.operation.name+" ";
}
mapping String::toActionState() :  StateMachine::State{
	name := self;
}

helper getRecieverName(in act : IOAutomaton::ActorObject) : String {
	if(act.oclIsKindOf(User))
		return "User";
	return act.oclAsType(SystemObject).name;
}

helper IOAutomaton::IOAutomaton::getFunctionNames() : Set(String) {
	return self.transition->select(inmessage != null)->collectNested(inmessage.operation.name)->asSet();
}

mapping String::constructInitState() : StateMachine::PseudoState {
	name := self;
	pseudoStateKind := PseudoStateKind::initial;
}

mapping IOAutomaton::Vertex::toState() : StateMachine::Vertex 	
	disjuncts IOAutomaton::InitialState::toInitialState,
	          IOAutomaton::State::toStableState;
	          
	          
mapping IOAutomaton::InitialState::toInitialState() : StateMachine::PseudoState {
	name := "entry";
	pseudoStateKind := PseudoStateKind::initial;
}


mapping String::constructState() : StateMachine::State {
	name := self;
}
mapping IOAutomaton::State::toStableState() : StateMachine::State {
	name := self.name;
}
mapping IOAutomaton::InMessage::toAcivityState() : StateMachine::State{
	name := self.operation.name;
}
