modeltype IOAutomaton uses IOAutomaton('se.studieren.mdd.transformer.IOAutomaton');
modeltype IOAutomatonPackage uses IOAutomatonPackage('se.studieren.mdd.transformer.IOAutomatonPackage');
modeltype StateMachine uses StateMachine('se.studieren.mdd.transformer.StateMachine');
modeltype StateMachinePackage uses StateMachinePackage('se.studieren.mdd.transformer.StateMachinePackage');
// modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');

transformation Step05(in ioAutomatonPackage : IOAutomatonPackage, out stateMachinePackage : StateMachinePackage);

main() {
	ioAutomatonPackage.objectsOfType(IOAutomatonPackage::IOAutomatonPackage).map toStateMachinePackage();
}

mapping IOAutomatonPackage::IOAutomatonPackage::toStateMachinePackage() : StateMachinePackage::StateMachinePackage {
	statemachine += self.ioautomaton.map toStateMachine();
}

mapping IOAutomaton::IOAutomaton::toStateMachine() : StateMachine::StateMachine {
	name := self.name; 
	
	var functionNames := self.getFunctionNames();
	
	
	region += functionNames.generateSubmachines(self);
	
	region += self.map toRegion(region);
	
}
mapping IOAutomaton::IOAutomaton::toRegion(in regions : Set(StateMachine::Region)) : StateMachine::Region {
	name := "Main Region";

	subvertex += self.vertex.map toState();
	
	
	//subvertex += activityStates->collect(name);
	// TODO Create Activity Diagrams 
	// TODO Create Submachines
	// TODO Create Transitions
}

helper String::generateSubmachines(in iOAutomaton : IOAutomaton::IOAutomaton ) : StateMachine::Region{
	
	var reg := self.map stringToReg();
	
	/// Initial State
	reg.subvertex += self.map constructInitState();	
	
	///Transitions used in this submachine
	var relatedTransitions = iOAutomaton.transition->select(inmessage != null)->select(inmessage.operation.name=self)->asSequence();
	log("test", self);
	foo(relatedTransitions,1,reg);
	
	return reg;
}

mapping String::stringToReg() : StateMachine::Region{
	name := self;
}

helper foo(in corrTransitions : Sequence(IOAutomaton::Transition), in count : Integer, inout reg : StateMachine::Region) : StateMachine::State{
	var oMessages := corrTransitions->first().outmessage->asSequence();
	var statename := "do / \n";
	var i := count;
	
	while(oMessages->at(i).returnvalue.oclIsKindOf(VoidValue) and i <= oMessages->size()){
		statename := statename + oMessages->at(i).getOutMessageSignature();
		i := i + 1;
	};
	
	if( oMessages->at(i).returnvalue.oclIsKindOf(Value) and i <= oMessages->size() ){
		statename := statename + oMessages->at(i).getOutMessageSignature();
	};
	
	var state := statename.map toActionState();	
	if(i != count){	//If no return value add state
		reg.subvertex += state;
		//TODO transition		
	};
	
	if( oMessages->at(i).returnvalue.oclIsKindOf(Value) and i <= oMessages->size() ){
		reg.subvertex += state;
		var results = corrTransitions.getResultsAt(i)->asSet();
		results->forEach(res){
			var resultingTransactions :=  corrTransitions->select(outmessage->at(i).returnvalue.oclAsType(Value).name = res);
			log ("123",resultingTransactions.outmessage->at(i).returnvalue.oclAsType(Value).name);
			var next := foo(resultingTransactions,i+1,reg);
			
		};
		//TODO transition
	};
	
	//should never occur, as this is loop condition, but to do a complete case for Kind
	if(oMessages->at(i).returnvalue.oclIsKindOf(VoidValue) and i <= oMessages->size()){
		log("ERROR","should never be called");
	};
	

	
	
	
	return state;
}


helper IOAutomaton::Transition::getResultsAt(in i:Integer) : String {
	return self.outmessage->at(i).returnvalue.oclAsType(Value).name;
}

helper IOAutomaton::OutMessage::getOutMessageSignature() : String {
//TODO check only if return value
	var ret := "";
	if(self.returnvalue.oclIsKindOf(Value)){
		ret := "check := ";
	};
	return ret+getRecieverName(self.actorobject)+"."+self.operation.name+"\n";
}
mapping String::toActionState() :  StateMachine::State{
	name := self;
}

helper getRecieverName(in act : IOAutomaton::ActorObject) : String {
	if(act.oclIsKindOf(User))
		return "User";
	return act.oclAsType(SystemObject).name;
}

helper IOAutomaton::IOAutomaton::getFunctionNames() : Set(String) {
	return self.transition->select(inmessage != null)->collectNested(inmessage.operation.name)->asSet();
}

mapping String::constructInitState() : StateMachine::PseudoState {
	name := self;
	pseudoStateKind := PseudoStateKind::initial;
}

mapping IOAutomaton::Vertex::toState() : StateMachine::Vertex 	
	disjuncts IOAutomaton::InitialState::toInitialState,
	          IOAutomaton::State::toStableState;
	          
	          
mapping IOAutomaton::InitialState::toInitialState() : StateMachine::PseudoState {
	name := "entry";
	pseudoStateKind := PseudoStateKind::initial;
}



mapping IOAutomaton::State::toStableState() : StateMachine::State {
	name := self.name;
}
mapping IOAutomaton::InMessage::toAcivityState() : StateMachine::State{
	name := self.operation.name;
}
