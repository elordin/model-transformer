modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype ScenarioTable uses ScenarioTable('se.studieren.mdd.transformer.ScenarioTable');
modeltype ScenarioTablePackage uses ScenarioTablePackage('se.studieren.mdd.transformer.ScenarioTablePackage');

transformation Step02(in uml: UML, out scenarioTablePackage: ScenarioTablePackage);

main() {
	uml.objectsOfType(Model).map toScenarioTablePackage();
}

mapping UML::Model::toScenarioTablePackage() : ScenarioTablePackage::ScenarioTablePackage {
	scenario += self.packagedElement[Interaction].map toScenarioTable();
}

mapping Interaction::toScenarioTable() : ScenarioTable::Scenario {

	state += self.fragment[StateInvariant].map transformStateInvariant();
	actor += self.lifeline.map transformLifeline();
	communication += self.message.map transformMessage();
	
}

query isUser(in l : Lifeline) : Boolean {
	return (l.name = "User") or (l.name = "user");
}

mapping StateInvariant::transformStateInvariant() : ScenarioTable::State {
	name := self.name;
}

mapping Lifeline::transformLifeline() : ScenarioTable::ActorObject
	disjuncts Lifeline::toUserObject,
	          Lifeline::toSystemObject;
    
mapping Lifeline::toUserObject() : ScenarioTable::User 
when {
	isUser(self);		
}{
	name := "User";
}

mapping Lifeline::toSystemObject() : ScenarioTable::SystemObject {
	name := self.name;
}

mapping Message::transformMessage() : ScenarioTable::Communication
	disjuncts Message::toUserCommunication,
			  Message::toSystemCommunication;

mapping Message::toUserCommunication() : ScenarioTable::UserCommunication 
when {
	isUserMessage(self);
}{
	usermessage := self.map toUserMessage();
	returned := returnValue(self);
}

mapping Message::toUserMessage() : ScenarioTable::UserMessage 
when {
	isUserMessage(self);
}{
	name := self.name;
	receiver := self.receiveEvent[MessageOccurrenceSpecification]->any(true).covered->any(true).map toUserObject();
	operation := object ScenarioTable::Operation{
		name := self.name;
	};
	sender := self.sendEvent[MessageOccurrenceSpecification]->any(true).covered->any(true).map transformLifeline();
}

query isUserMessage(in m : Message) : Boolean {
	var name = m.receiveEvent[MessageOccurrenceSpecification]->any(true).covered->any(true).name;
	return name = "User" or name = "user";
}

mapping Message::toSystemCommunication() : ScenarioTable::SystemCommunication 
when {
	self.messageSort != MessageSort::reply
}{

	var recipient : Lifeline = self.receiveEvent[MessageOccurrenceSpecification]->any(true).covered->any(true);
	
	var recipientCoveredBy : OrderedSet(InteractionFragment) = recipient.coveredBy->sortedBy(f | f.name.substring(1,2).toInteger());
	
	var receiveIndex = recipientCoveredBy->indexOf(self.receiveEvent[MessageOccurrenceSpecification]->any(true));
	var preReceiveSIs : OrderedSet(StateInvariant) = 
		recipientCoveredBy[StateInvariant]->select(s : StateInvariant | 
			recipientCoveredBy->indexOf(s) < receiveIndex);
	var postReceiveSIs : OrderedSet(StateInvariant) = 
		recipientCoveredBy[StateInvariant]->select(s : StateInvariant | 
			recipientCoveredBy->indexOf(s) > receiveIndex);
		
	prestate := preReceiveSIs->last().map transformStateInvariant();
	poststate := postReceiveSIs->first().map transformStateInvariant();
	
	systemmessage := self.map toSystemMessage();
	
	returned := returnValue(self);

}

mapping Message::toSystemMessage() : ScenarioTable::SystemMessage {
	name := self.name;
	sender := self.sendEvent[MessageOccurrenceSpecification]->any(true).covered->any(true).map transformLifeline();
	operation := object ScenarioTable::Operation{
		name := self.name;
	};
	receiver := self.receiveEvent[MessageOccurrenceSpecification]->any(true).covered->any(true).map toSystemObject();
}

helper returnValue(in m : Message) : ScenarioTable::ReturnValue {
	
	var sender = m.sendEvent[MessageOccurrenceSpecification]->any(true).covered;
	
	// Find following message ends
	var receiveMOC : MessageOccurrenceSpecification = m.receiveEvent[MessageOccurrenceSpecification]->any(true);
	var recipient : Lifeline = receiveMOC.covered->any(true);

	var recipientCoveredBy : OrderedSet(InteractionFragment) = recipient.coveredBy->sortedBy(f | f.name.substring(1,2).toInteger());
	var receiveIndex = recipientCoveredBy->indexOf(receiveMOC);
			
	if (m.name = "verifyAccount" or m.name = "verifyCardWithBank") {
	

	log(m.name);
	log("ReceiveIndex:\t" + receiveIndex.toString());
	log("MOC\t" + receiveMOC.toString());
	log("Recipient\t" + receiveMOC.covered->any(true).name);
	log("");
	log("1\t" + recipientCoveredBy[MessageOccurrenceSpecification]->select(true)->size().toString());
	log("2\t" + recipientCoveredBy[MessageOccurrenceSpecification]->select(moc | 
		recipientCoveredBy->indexOf(moc) > receiveIndex)->size().toString());
	log("3\t" + recipientCoveredBy[MessageOccurrenceSpecification]->select(moc | 
		recipientCoveredBy->indexOf(moc) > receiveIndex and
		(not moc.message->oclIsInvalid())
		)->size().toString());
	
	log(">\t" + recipientCoveredBy[MessageOccurrenceSpecification]->select(moc | 
		recipientCoveredBy->indexOf(moc) > receiveIndex and
		(not moc.message->oclIsInvalid())
		)->first().message.toString());
	
	log(">\t" + recipientCoveredBy[MessageOccurrenceSpecification]->select(moc | 
		recipientCoveredBy->indexOf(moc) > receiveIndex and
		(not moc.message->oclIsInvalid())
		)->first().message.messageSort.toString());
	
	log("4\t" + recipientCoveredBy[MessageOccurrenceSpecification]->select(moc | 
		recipientCoveredBy->indexOf(moc) > receiveIndex and
		(not moc.message->oclIsInvalid()) and
		moc.message.messageSort = MessageSort::reply)->size().toString());
		
	};
	
	var reply : Message = recipientCoveredBy[MessageOccurrenceSpecification]->select(moc | 
		recipientCoveredBy->indexOf(moc) > receiveIndex and
		(not moc.message->oclIsInvalid()) and
		moc.message.messageSort = MessageSort::reply and 
		moc.message.receiveEvent[MessageOccurrenceSpecification]->any(true).covered = sender)->first().message;	
	
	log("\t" + reply.name);
	// If exists return that message as return value
	if (not reply->isEmpty()) {
		return object ScenarioTable::Value {
			value := reply.name;
		}
	};
	return object ScenarioTable::VoidValue {};
	
}
